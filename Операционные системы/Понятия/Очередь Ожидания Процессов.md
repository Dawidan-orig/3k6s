Замороженные процессы попадают сюда, а потом идут отсюда обратно на выполнение.

Используется тип данных wait_queue_head_t через функцию DECLARE_WAITQUEUE().
Это процессы могут делать сами с собой, то-есть пользователь это контроллирует.
Потому если они делают это не правильно, то будет [[Race condition]] у активатора и замораживателя этого процесса.

Есть и встроенное решение:
1) Макрос DEFINE_WAIT()
2) add_wait_queue(), чтоб процесс сам себя добавил
3) prepare_to_wait(), чтоб избежать вышеописанную трудность
4) Ожидание активации, если было выбрано состояние INTERRUPTIBLE
5) Проверяем условие ожидание. Оттуда вызываем функцию schelude().
6) Переводим процесс в Running и удаляемся из очереди.