 Принимает сигналы (команды) для работы с прерываниями у процессора, централизуя их и позволяет их контролировать. Доступ к этой штуке должен быть минимизирован.

Чаще всего просто стартует и завершает операцию ввода-вывода и не отсвечивает. Используется во основном в драйверах, выключая их до завершения операции.

Работает в комбо с [[Процессорный Конвейер]], ведь прерывать конвейерные процессы следует с осторожностью (Нам не надо, чтобы только часть конвейера сработала)

Виды прерываний:
- Точные: Если после прерывания машина остаётся в определяемом состоянии
	1) Счётчик команд сохранён
	2) Все команды от счётчика выполнены
	3) Ни одна команда за пределами счётчика не была выполнена
	4) Известно состояние выполнения той команды, на которую указывает счётчик.
- Неточный: Если одно из условий не выполнилось. Тогда о процессе выполнения каждой из команд надо помнить, что грузит всё инфой.

Примером тут будет скрин: 
![[Pasted image 20240605201315.png]]

Последовательность работы прерываний:
1) Сохранить все регистры, которых не коснулась аппаратура, вызвавшая прерывание.
2) Отвечаем на вопрос: куда записывать и как? -> MMU, TLB либо же таблицы страниц
3) Устанавливаем стек
4) Посылаем сигнал подтверждения контроллеру, либо же разрешаем прерывания
5) Копируем регистры в таблицу процессов (Отвязываем связанные с процессом данные в память)
6) Извлекаем информацию из устройства, пославшего прерывание. Запускаем, сбстно, обработку
7) Выбираем следующий процесс. НО! Если прерывание привело к готовности какого-то процесса - пускаем (Скорее всего) его, тут уж как планировщик решит.
8) Обновляем MMU и/или TLB для нового процесса
9) Загружаем все регистры нового процесса
10) Запускаем этот процесс.