Содержит в себе [[Очередь Ожидания Процессов]], если приводить аналогию из ИмМод.
Занимается распределением вычислительных ресурсов по [[Процесс|процессам]].

- Долгосрочное планирование: Определяем "Степень мультипрограммирования" (Насколько сильно дробятся процессы при последовательном выполнении), подразумевает что новые процессы загружаются после выполнения текущих.
- Короткосрочное: Перевод [[Состояния процесса]] из Готовности в Исполнение. Нужно для учёта тактовой частоты учёта контроля [[Проблема ввода пользователя|ввода]].

Работа:
1) Выбор процесса через [[Алгоритм CFS]]
2) Получили процесс из алгоритма, через самый левый узел у RB-дерева.
3) Выполнили отведённое время, повторили
Если нужно добавить новый процесс:
1) Короткосрочное планирование перевод процесс в новое состояние
2) Обновляем данные в [[Linux sched_entity structure]]
3) Вставляем в RB-дерево для CFS. profit.
Удаление процесса:
1) Процесс блокируется или завершается. Это и приводит к удалению
2) Удаляем из RB-дерева по его логике.

Сидит планировщик в `kernel/sched.c` у Linux. Там есть функция `schelude()`, которая время от времени и вызывается, в формате [[Поток ядра|потока ядра]].
Эта функция очень проста, и чрезвычайно оптимизирована. Нам же не надо, чтобы время планирования было дольше времени исполнения.

Классификация планировщиков:
- Completely Fair Scheluder (CFS) -- Используется по умолчанию в Linux обычно. Чистый динамически изменяемый [[Алгоритм CFS]]
- Real-Time -- Очень тонконастраиваемый планировщик для высокоприоритетных процессов с жёсткими требованиями выполнения.
- Batch -- Для фоновых процессов
- Idle -- Если процессору делать совсем нечего, работает этот планировщик для совсем малоприоритетных задач.

Сумбурная, но потом отредактированная запись лекций:
Есть процессы, две штуки.
Проблемы с ними:
1) Надо чтобы оба процесса имели "справедливый" доступ к системе. То-есть все процессы должны выполнятся, и притом максимально эффективно.
2) Контроль планирования времени - в Linux с версии 2.6. его сделали равномерным. Для того используется [[Квант Времени]]
3) ? (См. 82-я страница)
4) ? (См. 82-я страница) #Переписать 
5) Справедливый планировщик.
Вот тут подходы расходятся.
Есть кванты времени, по ним ориентируемся для исполнения. Квант времени - это то время, после которого процесс вытесняется (некая константа)

Есть приоритеты процесса, но мы не обязательно знаем время выполнения.
Надо распределить теперь время выполнения относительно приоритетов равномерно по времени, ибо иначе долговременные процессы будут выполнятся, что логично, долго, буквально провисая.

Значит надо сделать какую-то равномерность в относительном распределении. Увеличить время для долговременных, уменьшить - для коротких. И ещё учесть приоритеты. более приоритетные обслуживаются тоже дольше.

Может использовать [[Round Robin]] например, для решения этой задачи в итоге.

Основная беда - сделали распределение, запустили, а потом один из процессов ушёл в блокировку раньше времени. Решение:
Запускаем после него следующий, это логично.
Первый выходит из блокировки - запускаем его вновь, останавливая второй.
И потом, наконец, добиваем второй.
(PREEMT из GPSS).

Бывает и такое, что процесс сам себя блокирует, планировщик должен учесть этот момент.

Минус - слишком высокие приоритеты блокируют вообще всё.
[[Проблема ввода пользователя]] - как раз одна из таких ситуаций, ввод должен быть мгновенным. Для этого сделали разделение на IO-Bound, и CPU-Bound разделение. Что примечательно - обе штуки могут быть разом в одном процессе.
Итого, собираем в кучу:
- Есть влияние встроенного в каждый процесс приоритета
- Есть Алгоритмы оценки сложности исполнения процесс
- Есть IO-Bound, который повышает приоритет

Одинаковый приоритет процессов = [[Round Robin]].

И это всё только лишь про "priority-based" подход в распределение процессов, который используется в Linux. (А на деле их, так то, больше)

[[Приоритезация процесса]]