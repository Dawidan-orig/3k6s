Состоит конвейер из этапов, и вся прелесть в том, что на этапе n процессор разом делает действие для этапа n+1 следующего конвейера, и n+2 следующих двух.
То-есть конвейеры кладутся друг на друга со смещением в 1 этап, что позволяет ооочень здорово оптимизировать подачу и выполнение команд.

Пример:
i486: {Загрузка}->{Основное декодирование (?)} -> {Вторичное декодирование (?)} -> {Выполнение} -> {Запись результата в регистры}

Проблемы:
1) Каждый элемент структуры - это команда любой форма. Одна может выполнятся долго, другая - очень быстро. Может произойти локальная версия Deadlock'а, если одной команде надо ожидать результат другой
2) Вся структура пойдёт под откос, если заранее не была определена адекватность текущего идущего конвеера и если он в каком-то этапе весь встанет. Он в итоге отменится, данные выгрузятся, но это всё время.
3) Разные форматы работы. Некоторые конвееры после записи читают, некоторые - записывают. Иногда два раза записывают.

Конкретные примеры:
- Pentium: 2 конвеера i486
- ООО (out-of-order) умеет заранее упреждать исполнение команд и не имеет вот прям чёткой структуры. Решает 2-ю проблему чисто за счёт своей архитектуры. Тут конвеер уже весьма сложный
	- [[Кэш и уровни Кэша|Level 2 buffer]] -> fetch buffer
	- Оттуда отправляется в этап декодирования инструкции (Сейчас процессоры могут за такт 4 инструкции расщепить) (ROB,)
	- Получившиеся микрооперации надо пересохранить в разные регистры, но так, чтоб не помешать уже сохранённым регистрам других процессов (Reservation Buffer), скорее всего работает тут с Портами (Средство взаимодействия процессора с остальными устройства)
	- Через Порты занимаемся выполнением задач. Там может быть АЛУ, Сетевая карта, логика действия зашита, как я понял, в порт, а потому обращаясь к ним уже выполняется определённое действие. То-есть чтение-запись те же, например.