IPC, Inter-process communication.

Лабораторная 1.
Главное: fopen, fclose. Работа с файлами. 
Знать: [[i-node система]], (И ньюанс, что уже используемый файл нельзя использовать)

Лабораторная 2, про управление процессами.
Главное: [[Команда fork и vfork]], [[Команда exec]], [[Команда signal]]

Лабораторная 3, межпроцессное взаимодействие.
Главное: 

Вариант 1, Канал обмена данными между процессами:
Используем уже имеющуюся в Linux функцию pipe - создание канала.
Каналы создают два файла, и мы получаем два дескриптора (ID файла, по сути указатель).
Записывая и читая через эти штуки можно получать данные.

Сам по себе канал односторонний, но можно попробовать извернуться для двухстороннего канала (По факту это будет один канал)

Вариант 2, разделяемая память (Linux), Shared Memory:
Чисто [[Виртуальное адресное пространство]] (А точнее его неиспользование) и [[3k6s/Операционные системы/Понятия/Память/Критическая Секция]], берём часть в памяти и резервируем её, делая её как раз такой секцией.
Встроенная функция для этой штуки - shmget, возвращает ID открытой памяти (Для прямой записи.)

а shmat позволяет получить по одному адресу - другой адрес.
(Пожалуйста, используйте posix, тут нейминги кошмарные.)

Вариант 3, Очереди сообщений (Linux)
Суть в том, чтобы дождаться, когда процесс будет готов принимать данные, и загрузить очередь сообщений в него.
Сообщение - это пользовательская структура, например.

Системные вызовы, Сообщения.
msgget (создание очереди сообщений либо подключение к существующей) - Возвращает ID для очереди.
msgsnd - Запись
msgrcv - Получить сообщение.

Проблема тут в том, что сообщения - маленькие, их надо - чистить, а доступ к очереди - вообще ограничен. Ибо надо иметь процессу нужные права доступа. Хотя это скорее в современности хорошо, ибо можно дров наломать.

Вариант 4, INET сокеты
Работа через [[Сокет|сокеты]], аналогичные сетевым

Вариант 5, Сокеты домена Unix
Unix Domain Sockets, UDS. Тоже [[Сокет|сокеты]]. Специально созданы для межпроцессорного взаимодействия.

Вариант 6, пользовательские сигналы SIGUSR1-2
Работаем по [[Команда signal|сигналам]], по ним определяем готовность передавать данные. Всо.

Вариант 7, Сигналы SIGPIPE, SIGCHILD
По сути просто вариант 1 (SIGPIPE) и использование fork (SIGCHILD), но мы не можем использовать эти сигналы для чего-либо.

SIGPIPE приходит при успешном создании [[Команда signal|сигнала]] или [[Сокет|сокета]],
SIGCHILD - информирование об изменении состояния дочернего процесса, 

Вариант 8, Очереди сообщений POSIX
Вариант 3, но функции тут следующие:
mq_open - открытие (существующего)/создание очереди
mq_close - закрытие очереди
mq_send - Отправляем
mq_recieve - Принимаем.
Это - ключевое.

У сообщений тут есть параметры, и можно уведомлять о получении сообщений. То-есть получать сигнал, когда готовы принимать (для асинхрона, чтоб процессы не стояли)

Вариант 9, разделяемая память POSIX
Тут у нас используются файлы, которые являются репрезентацией в памяти.
Точно так же shm_open вроде.

Вариант 10, RPC (XML-RPC)
Удалённый вызов процедур.
Внешняя штука вызывает внутреннюю публичную функцию, которая привязана к нужному поведению

Эта публичная функция и есть RPC.

Лабораторная 4, [[Поток вычисления|многопоточность]], pthread
Выполняем задачу несколькими ядрами процессора

pthreadcreate - Создание потока
pthreadjoin - Позволяет ожидать завершение указанного потока ([[Barrier]] внутренней реализации для одного потока, по сути)
pthreadexit - уничтожение (По сути) потока

Лабораторная 5, разделение ресурсов и [[3k6s/Операционные системы/Понятия/Память/Критическая Секция]]

Всё, что тут есть - это про архитектуру работы с критической секцией. Дальше врубайте творческое мышление, да решайте задачу