processID fork().
(vfork() не копирует записи таблиц страниц родителя, и новый процесс создаётся вообще отдельно в ВАП родителя.
Притом родитель замораживается, пока дочерний процесс не сделает exec() или не исчезнет.
Делать запись дочерний процесс не может.)

Команда создаёт копию родительского [[Процесс|процесса]], полную!
Со всей информацией, что была в процессе.

Но [[Виртуальное адресное пространство]] будет другим уже, но притом тоже скопированным.

Если processID=0 то имеем дочерний процесс.
Для главных будет, соответственно, $\neq0$

Это единственный способ создать новый процесс в Linux, там команда будет в виде системного вызова clone().
Кроме того, есть ещё система оптимизации:
- Новосозданные процессы, пока не записывают, работают с одним ВАП
- Стоит только сделать запись, как для записывающего будет скопировано всё в новый ВАП.

Последовательность создания процесса в Linux
---
1) dup_task_struct() создаёт новый стек ядра и структуры thread_info и [[Linux task structure]],
2) будет ли исчерпан лимит на количество процессов у пользователя?
3) Разбиваем дочерний и родительский процессы. У дочернего все поля очищаются/ставятся в начальные значения. Б*о*льшая часть структуры task_structure не меняется.
4) Дочерний процесс переводится в TASK_UNINTERRUTIBLE.
5) copy_process()->copy_flags() ставит значения флагов в task_struct
6) alloc_pid() - устанавливаем новый process ID (PID)
7) Определяется, нужно ли выделять для нового процесса ВАП и другие объекты или можно использовать родительский.
8) в copy_process() делается финальная зачистка структур данных и функция возвращается указатель на дочерний процесс.