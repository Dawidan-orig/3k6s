Код ядра не может вызываться из пользовательских приложений напрямую.
Так что мы делаем эдакий интерфейс, который сразу содержит в себе все необходимые вызовы штук (Чтоб уменьшить риск всё напрочь сломать)

У нас тут три [[Уровни ПО]], которые мы используем:
Пользовательский - это то место, где и пишем код.
Библиотека C -> Полусторонние, полупереписанные Linux'ом системы.
Системы Linux -> Планировщик, интефрейсы для пользователя, структуры...
Уровень языка C -> Переводы языка, когда мы к ним обращаемся
Уровень ядра.

Вот этот обработчик сидит на уровне систем Linux, получается.
Тут вся суть в том, что системные функции - очень быстрые, так как максимально приближены к ядру.

Конкретный пример:
read() -> [read()] (C Lib) -> system_call() (Обработчик) -> sys_read() (Системный вызов)

Последние два - в пространстве ядра.

Этот обработчик является лишь менеджером всех функций с инверсией зависимости, а потому добавление новых системных функций - не зависимая от него задача (Регистрируется новая функция просто).

1) Single Responsibility. Определяем, что будет делать функция
2) Аргументы и что возвращается. Область определения, Область значений.
3) Делаем её максимально гибкой. Чтоб и через 30 лет использовалась.
4) Делаем её минимального размера, максимально простой (KISS)
5) Желательно для решения использовать то, что уже реализовано в Linux/C (DRY)
Короче все правила хорошего кода.

Потом классика: Тесты (Проверка параметров, проверка работоспособности и возвращаемых результатов.)